package app_test

import (
	"errors"
	"io/ioutil"
	"os"
	"strings"
	"testing"

	"github.com/stretchr/testify/require"
	"github.com/typical-go/typical-go/internal/app"
	"github.com/typical-go/typical-go/pkg/oskit"
	"github.com/typical-go/typical-go/pkg/typgo"
)

func TestSetup(t *testing.T) {
	var out strings.Builder
	app.Stdout = &out
	defer func() { app.Stdout = &out }()

	defer oskit.MkdirAll("some-pkg")()

	c := &typgo.Context{
		Context: cliContext([]string{
			"-project-pkg=some-pkg",
		}),
	}
	defer c.PatchBash([]*typgo.MockBash{})(t)

	require.NoError(t, app.Setup(c))

	b, _ := ioutil.ReadFile("some-pkg/typicalw")
	require.Equal(t, `#!/bin/bash

set -eu

PROJECT_PKG="some-pkg"
BUILD_TOOL="tools/typical-build"
TYPTMP=.typical-tmp
TYPGO=$TYPTMP/bin/typical-go
TYPGO_SRC=github.com/typical-go/typical-go

if ! [ -s $TYPGO ]; then
	echo "Build $TYPGO_SRC to $TYPGO"
	go build -o $TYPGO $TYPGO_SRC
fi

$TYPGO run \
	-project-pkg=$PROJECT_PKG \
	-typical-build=$BUILD_TOOL \
	-typical-tmp=$TYPTMP \
	$@
`, string(b))

	require.Equal(t, "Create 'some-pkg/typicalw'\n", out.String())
}

func TestSetup_GetParamError(t *testing.T) {

	os.Mkdir(".typical-tmp", 0777)
	defer os.RemoveAll(".typical-tmp")

	c := &typgo.Context{
		Context: cliContext([]string{}),
	}
	defer c.PatchBash([]*typgo.MockBash{
		{CommandLine: "go list -m", ReturnError: errors.New("some-error")},
	})(t)

	err := app.Setup(c)
	require.EqualError(t, err, "some-error: ")
}

func TestSetup_WithGomodFlag(t *testing.T) {
	var out strings.Builder
	app.Stdout = &out
	defer func() { app.Stdout = &out }()

	defer oskit.MkdirAll("somepkg")()

	c := &typgo.Context{
		Context: cliContext([]string{
			"-project-pkg=somepkg",
			"-go-mod",
		}),
	}
	defer c.PatchBash([]*typgo.MockBash{
		{CommandLine: "go mod init somepkg"},
	})(t)

	require.NoError(t, app.Setup(c))
	require.Equal(t, "Initiate go.mod\nCreate 'somepkg/typicalw'\n", out.String())
}

func TestSetup_WithGomodFlag_Error(t *testing.T) {
	var out strings.Builder
	app.Stdout = &out
	defer func() { app.Stdout = &out }()
	defer oskit.MkdirAll("somepkg")()

	c := &typgo.Context{
		Context: cliContext([]string{
			"-project-pkg=somepkg",
			"-go-mod",
		}),
	}
	defer c.PatchBash([]*typgo.MockBash{
		{CommandLine: "go mod init somepkg", ErrorBytes: []byte("error-message"), ReturnError: errors.New("some-error")},
	})(t)
	err := app.Setup(c)
	require.EqualError(t, err, "some-error: error-message")
	require.Equal(t, "Initiate go.mod\n", out.String())
}

func TestSetup_WithGomodFlag_MissingProjectPkg(t *testing.T) {
	var out strings.Builder
	app.Stdout = &out
	defer func() { app.Stdout = &out }()

	defer oskit.MkdirAll("somepkg")()

	c := &typgo.Context{
		Context: cliContext([]string{"-go-mod"}),
	}
	defer c.PatchBash(nil)(t)

	err := app.Setup(c)
	require.EqualError(t, err, "project-pkg is empty")
	require.Equal(t, "Initiate go.mod\n", out.String())
}

func TestSetup_WithNewFlag(t *testing.T) {
	var out strings.Builder
	app.Stdout = &out
	defer func() { app.Stdout = &out }()

	c := &typgo.Context{
		Context: cliContext([]string{
			"-project-pkg=somepkg1",
			"-new",
		}),
	}
	defer c.PatchBash(nil)(t)

	err := app.Setup(c)
	require.NoError(t, err)
	defer os.RemoveAll("somepkg1")

	require.Equal(t, `Create 'somepkg1/cmd/somepkg1/main.go'
Create 'somepkg1/internal/app/start.go'
Create 'somepkg1/internal/generated/ctor/ctor.go'
Create 'somepkg1/tools/typical-build/typical-build.go'
Create 'somepkg1/typicalw'
`, out.String())

	b, _ := ioutil.ReadFile("somepkg1/cmd/somepkg1/main.go")
	require.Equal(t, `package main

// Autogenerated by Typical-Go. DO NOT EDIT.

import (
	"fmt"
	"log"

	"somepkg1/internal/app"
	_ "somepkg1/internal/generated/ctor"
	"github.com/typical-go/typical-go/pkg/typapp"
	"github.com/typical-go/typical-go/pkg/typgo"
)

func main() {
	fmt.Printf("%s %s\n", typgo.ProjectName, typgo.ProjectVersion)
	if err := typapp.StartService(app.Start, app.Stop); err != nil {
		log.Fatal(err)
	}
}
`, string(b))

	b, _ = ioutil.ReadFile("somepkg1/internal/app/start.go")
	require.Equal(t, `package app

import (
	"bufio"
	"fmt"
	"os"
	"time"
)

// Start app
func Start() {
	// TODO: change start app implementation
	fmt.Println("Hello world!")
	fmt.Print("Press 'Enter' to continue...")
	bufio.NewReader(os.Stdin).ReadBytes('\n')
}

// Stop app
func Stop() {
	// TODO: change graceful shutdown implementation
	fmt.Printf("Stop app at %s", time.Now())
}
`, string(b))

	b, _ = ioutil.ReadFile("somepkg1/tools/typical-build/typical-build.go")
	require.Equal(t, `package main

import (
	"github.com/typical-go/typical-go/pkg/typast"
	"github.com/typical-go/typical-go/pkg/typapp"
	"github.com/typical-go/typical-go/pkg/typgo"
	"github.com/typical-go/typical-go/pkg/typmock"
)

var descriptor = typgo.Descriptor{
	ProjectName:    "somepkg1",
	ProjectVersion: "0.0.1",

	Tasks: []typgo.Tasker{
		// annotate
		&typast.AnnotateProject{
			Sources: []string{"internal"},
			Annotators: []typast.Annotator{
				&typapp.CtorAnnot{},
			},
		},
		// build
		&typgo.GoBuild{},
		// run
		&typgo.RunBinary{Before: typgo.TaskNames{"annotate", "build"}},
		// mock
		&typmock.GoMock{
			Sources: []string{"internal"},
		},
	},
}

func main() {
	typgo.Start(&descriptor)
}
`, string(b))
}
